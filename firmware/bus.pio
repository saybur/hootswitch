;
; Copyright (C) 2024 saybur
;
; This program is free software: you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program.  If not, see <https://www.gnu.org/licenses/>.
;

;
; This file has definitions for ADB bus fuctions using PIO on the RP2040, both
; for host and device implementations. Combined with some timer alarms, this
; allows tracking buses without using much CPU time.
;
; Each bus port will need at least one state machine. ADB is slow enough you
; have time to swap PIO programs in and out, which is the technique Hootswitch
; uses for managing a relatively large number of ports.
;
; See the rest of the C code for working examples. I could see this being
; interesting to other projects, so if you see areas where things are
; inefficient, badly documented, or just plain wrong please open a PR :)
;
; ----------------------------------------------------------------------------
; For simplicity these functions are all hard-coded to use a 125MHz main clock.
; Do not change the system clock without updating the clock dividers!
; ----------------------------------------------------------------------------


; Writes data bits from the TX FIFO to a bus, including a '1' start bit and the
; low pulse of the '0' stop bit. This also checks for collisions if configured.
; This is used when acting as an emulated device, only in response to Talk
; Register from one of the machines. See the next entry for the version used
; when operating as a host.
;
; The TX FIFO must have something in it when this is started to avoid stalling
; at an inopportune location. When the FIFO depletes the stop bit will be sent
; and an interrupt will be raised on the IRQ bit matching the state machine.
; The FIFO is joined so has enough space for 8 bytes of data, which is the most
; the protocol allows anyway.
;
; Collision detection works by checking the state of a given pin during a '1'
; data bit. If it is detected low someone else is sending a '0' simultaneously;
; this will halt and raise both the above IRQ and IRQ+4. This feature can be
; disabled by providing an input pin that is always high.

.program bus_tx_dev
.side_set 1

	nop             side 1 [6]  ; '1' bit low, 35us
	nop             side 0 [12] ; '1' bit high, 65us

tx_bs:
	out x, 1        side 1 [5]  ; low 30us, fetch bit value
	jmp !x tx_0     side 1      ; low +5us, decide if should be released
	nop             side 0 [1]  ; release now, 10us high
	jmp pin tx_be   side 0 [3]  ; check for collision, +20us high
	irq 4 rel       side 0      ; if pin still low, set flag for collision
tx_end:
	irq wait 0 rel  side 0      ; idle pin, stop, let CPU know xmit is done
tx_0:
	nop             side 1 [5]  ; low +30us

tx_be:
	jmp !osre tx_bs side 0 [6]  ; +35us high, loop if more data

	jmp tx_end      side 1 [12] ; assert stop bit for 65us then goto end

% c-sdk {
static inline void bus_tx_dev_pio_config(pio_sm_config *c,
		uint32_t offset, uint32_t pin_write, uint32_t pin_read)
{
	*c = bus_tx_dev_program_get_default_config(offset);
	sm_config_set_sideset_pins(c, pin_write);
	sm_config_set_jmp_pin(c, pin_read);
	sm_config_set_out_shift(c, false, true, 8); // shift left (see below)
	sm_config_set_fifo_join(c, PIO_FIFO_JOIN_TX);
	sm_config_set_clkdiv_int_frac(c, 625, 0); // 5us/clk
}

static inline void bus_tx_dev_put(PIO pio, uint8_t sm, uint8_t v)
{
	// left justify data (MSB first) via narrow bus writes
	// a bit cryptic, but see datasheet 3.6.1 for details
	io_rw_8 *txf = (io_rw_8 *) &(pio->txf[sm]);
	*txf = v;
}
%}


; Writes command or data bits from the TX FIFO to the bus, including the
; preable/postable. This version is used when acting as a host. It is similar
; to the above one except for the following:
;
; 1) The start will be attention with sync _or_ '1' start bit, depending on
;    what offset is used,
; 2) Collision checking is not applied since hosts do not need it.
;
; Otherwise the notes in the other version apply. The design of these is quite
; similar so you could potentially merge them; on Hootswitch these exist on
; different PIO units, so the differences help shave off a few instructions.
;
; This is used both during the command phase and when issuing a Listen Register
; data operation. The normal offset is the '1' bit for sending data. Starting
; at (offset + 2) gets attention/sync instead for commands.
;
; For attention/sync, you need to provide an initial TX FIFO value for the
; length of the low pulse. For regular attention a value of 15 is appropriate
; ((15+1)*50=800). To make this a reset pulse use 59 instead.
;
; All versions of this will sample the line after releasing it the final time.
; If it is still detected low, rel IRQ+4 is set and this waits until the line
; goes high again before returning. This is useful to detect SRQ during
; commands and (far less likely) finding spurious line errors.

.program bus_tx_host
.side_set 1

	nop             side 1 [6]  ; '1' bit low, 35us
	jmp txh_bs      side 0 [12] ; '1' bit high, 65us

	out x, 8        side 0      ; <- entry point for attention/sync
txh_atn:
	jmp x-- txh_atn side 1 [9]  ; attention, 800us low
	nop             side 0 [13] ; sync, 70us high

txh_bs:
	out x, 1        side 1 [5]  ; low 30us, fetch bit value
	jmp !x txh_0    side 1      ; low +5us, decide if should be released
	jmp txh_be      side 0 [5]  ; release now, 30us high
txh_0:
	nop             side 1 [5]  ; low +30us

txh_be:
	jmp !osre txh_bs side 0 [6] ; +35us high, loop if more data

	nop             side 1 [12] ; assert stop bit for 65us
	nop             side 0 [7]  ; wait 40us
	jmp pin txh_e   side 0      ; skip to end if line high
	irq 4 rel       side 0      ; otherwise set the SRQ detection flag
	wait 1 pin 0    side 0      ; then wait for the line to go high
txh_e:
	irq wait 0 rel  side 0      ; done

% c-sdk {
static inline void bus_tx_host_pio_config(pio_sm_config *c,
		uint32_t offset, uint32_t pin_write, uint32_t pin_read)
{
	*c = bus_tx_host_program_get_default_config(offset);
	sm_config_set_sideset_pins(c, pin_write);
	sm_config_set_jmp_pin(c, pin_read);
	sm_config_set_in_pins(c, pin_read);
	sm_config_set_out_shift(c, false, true, 8); // shift left (see below)
	sm_config_set_fifo_join(c, PIO_FIFO_JOIN_TX);
	sm_config_set_clkdiv_int_frac(c, 625, 0); // 5us/clk
}

static inline void bus_tx_host_put(PIO pio, uint8_t sm, uint8_t v)
{
	io_rw_8 *txf = (io_rw_8 *) &(pio->txf[sm]);
	*txf = v;
}
%}


; Reads bits from a connected machine to the RX FIFO. Should be started while
; the line is high on the sync signal or Tlt of the relevant transaction.
;
; Unlike the following reading method this one relies on hosts having no more
; than +/- 3% timing deviation, which makes processing much simpler.
;
; The decision to issue a SRQ depends on knowledge of state beyond what PIO
; is (probably) capable of, so as soon as the stop bit assertion begins this
; does the following:
;
; 1) A non-wait IRQ is triggered to get the CPU's attention.
; 2) This waits for about 50us, then pulls from the TX FIFO.
; 3) If a value is in the TX FIFO this will drive the output line low for the
;    time requested (value * 3us, 78 is a reasonable value) then re-issue the
;    IRQ and wait.
; 4) If no value is in the TX FIFO the pull will instead block, not touching
;    the output line.
;
; This version is used both during the command phase and Listen Register data
; operations. The normal offset will discard the '1' start bit. Starting at
; (offset + 2) should be used during commands.

.program bus_rx_dev
.side_set 1

	wait 0 pin 0    side 0      ; discard '1' start bit if needed
	wait 1 pin 0    side 0

	out x, 8        side 0      ; load the counter for how many bits to read
rx_b:
	wait 0 pin 0    side 0 [14] ; wait for line to go low, then ~50us to center
	in pins, 1      side 0      ; fetch line state
	wait 1 pin 0    side 0      ; wait for line to go high (might be already)
	jmp x-- rx_b    side 0 [1]  ; loop if expecting more data

	wait 0 pin 0    side 0      ; wait until the stop bit begins
	irq 0 rel       side 0 [15] ; notify CPU we are at stop bit & wait ~50us
	out x, 8        side 0      ; load SRQ duration, or stall if not provided
rx_s:
	jmp x-- rx_s    side 1      ; drive SRQ
	irq wait 0 rel  side 0      ; release and re-notify
.wrap

% c-sdk {
static inline void bus_rx_dev_pio_config(pio_sm_config *c,
		uint32_t offset, uint32_t pin_write, uint32_t pin_read)
{
	*c = bus_rx_dev_program_get_default_config(offset);
	sm_config_set_in_pins(c, pin_read);
	sm_config_set_sideset_pins(c, pin_write);
	sm_config_set_in_shift(c, false, true, 8); // shift left
	sm_config_set_out_shift(c, true, true, 8); // shift right
	sm_config_set_clkdiv_int_frac(c, 375, 0); // 3us/clk
}
%}


; Listens to the bus for attention/reset, interrupting the CPU when a signal of
; interest is detected. This provides a CPU-free way to both seek that specific
; (long) signal and ignore transactions we don't care about, like machine/non-
; owned device chatter.

.program bus_atn_dev

	out y, 16                   ; pull in the countdown value
atn_no:
	wait 0 pin 0                ; wait for the line to drive low
	mov x, y                    ; reset countdown
atn_cnt:
	jmp pin atn_no              ; if pin goes high before expire, try again
	jmp x-- atn_cnt             ; tick down

atn_yes:
	jmp pin atn_done            ; made it past minimum, wait to go high
	jmp x-- atn_yes             ; until we do, countdown with overflowed X
atn_done:
	in x, 16                    ; store and be done
	irq wait 0 rel

% c-sdk {
static inline void bus_atn_dev_pio_config(pio_sm_config *c,
		uint32_t offset, uint32_t pin_read)
{
	*c = bus_atn_dev_program_get_default_config(offset);
	sm_config_set_jmp_pin(c, pin_read);
	sm_config_set_out_shift(c, true, true, 16); // shift right
	sm_config_set_clkdiv_int_frac(c, 125, 0); // 1us/clk
}
%}


; Reads bits from a device's response into the RX FIFO. This is used by the
; host implementation while listening to Talk Register issued by a native
; device.
;
; The bus protocol for devices is loose, allowing a +/- 30% deviation from
; nominal timings. To accomodate oddball devices this routine counts the
; duration of the low & high parts of a bit pulse and pushes the residual
; timeout countdown into the RX FIFO for later interpretation by the CPU as '0'
; and '1' based on which part of the signal has a _lower_ value, indicating
; that part took longer. Outputs are 16-bit words, structured like this:
;
; - If (v >> 8) < (v & 0xFF), '0' bit
; - If (v >> 8) > (v & 0xFF), '1' bit
;
; Timeouts here are common, both due to Tlt expiring without a transmission and
; the remote device stopping a data transfer. To avoid a deadlock two
; mechanisms are used:
;
; 1) A countdown value is used both to measure the length of the pulses and
;    establish a maximum after which a timeout is registered; submit a value of
;    110 in almost all cases, which produces a line-idle timeout of 88us and a
;    Tlt max of ~264us, both quite generous to slow devices.
; 2) Outside the PIO, an alarm should be set up for the maximum possible xmit
;    time.
;
; This pushes somewhat frequently; suggest using a DMA unit to route the data
; somewhere convenient to save on CPU time.

.program bus_rx_host

	out y, 8                    ; load max countdown from TX FIFO via autopull
	mov x, y                    ; setup for Tlt timeout
rxh_tlt:
	jmp x-- rxh_tlt_nto         ; countdown to max Tlt
	irq wait 0 rel              ; stop, inform CPU of timeout
rxh_tlt_nto:
	jmp pin rxh_tlt         [4] ; if high, continue waiting for Tlt to end

.wrap_target
	mov x, y                    ; setup countdown
rxh_l:
	jmp pin rxh_hs              ; execute jump once pin goes high
	jmp x-- rxh_l               ; otherwise decrement
	irq wait 0 rel              ; if we get here, timed out low, phase error?
rxh_hs:
	in x, 8                     ; store what's left of low count
	mov x, y                    ; reload countdown for high side of bit
rxh_hi:
	jmp x-- rxh_hnt             ; skip next until we time out
	irq wait 0 rel              ; timed out, notify CPU of data phase end
rxh_hnt:
	jmp pin rxh_hi              ; loop until pin goes low again
	in x, 8                     ; pin low, on to next bit: store and loop back
.wrap

% c-sdk {
static inline void bus_rx_host_pio_config(pio_sm_config *c,
		uint32_t offset, uint32_t pin_read)
{
	*c = bus_rx_host_program_get_default_config(offset);
	sm_config_set_jmp_pin(c, pin_read);
	sm_config_set_in_shift(c, false, true, 16); // shift left
	sm_config_set_out_shift(c, true, true, 8); // shift right
	sm_config_set_clkdiv_int_frac(c, 50, 0); // 0.4us/clk
}
%}
